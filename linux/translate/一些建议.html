<!doctype html>
<html lang="zh_cn">
  <head>
    <!-- Required meta tags -->

    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <!-- keywords for search engin -->
    <meta name="keywords" content="emacs,org,shell,linux,c,python,js,html,css">
    <meta name="author" content="Peng Xie">
    <meta name="description" content="">
    <link rel="stylesheet" href="../../css/indexlayout.css" />
    <script defer src="../../js/main.js"></script>

    <title>一些建议</title>

  </head>

  <body>

    <div class="main">
      <div class="nav">
        <div w3-include-html="学习GNU开发工具链_index.html"></div>
      </div>

      <div class="article">
        <h2>一些建议</h2>

        <p>在软件工程中，开发者从精准的、定义良好细节的开始，然后开始实施。
          在调查过程中，细节总是易变的，而目标总是解决每天都在一点点改变的问题。
          而问题就在于，如果使用灵活的方式，使得在变来变去过程中不至于太大惊小怪。
          我们指的是对调试、测试和验证大惊小怪。
          一旦开发者有代码能解决一些指定的问题，他们总是希望能尽量少地为解决类似问题的不同细节而重新发明、调试和测试。
          这是程序员在生活中遇到的两种截然不同的情况。</p>

        <p>软件工程师在这两种情况下都能应对自如，这是他们训练的一部分。
          但是那些专业不是软件工程而是科学问题的人，他们由于缺少软件工程相关的训练，所以必然会面临这两种情况中最难的那部分：第二种情况。
          因此，他们的代码实现很笨拙、使用方式很笨拙，事实上，只有牺牲质量才能得到正确的结果。
          这样，他们确实是把当天的工作完成了，但是，他们没有为明天的工作留下一点点遗产。
          没有通用的工具，没有文档，没有可重用的代码。
        </p>

        <p>软件工程的关键在于不要开发只作一件事情的单一应用程序，而应该关注开发库。
          可以把库解释为具有多个入口点的程序。
          你写的每一个库都可以做为遗产留给其它开发者。
          就像数学一样，使用一些简单的定理来定义新的、简单的定理，从而隐藏更大定理中的复杂性。
          在软件工程中，您可以开发库来一劳永逸地处理一些低级的细节问题。
          以便在每次针对问题的变体的不同实现时，它们都不受影响。
        </p>

        <p>
          站在更高的角度上来说，您不应该只创建一个应用程序，应该创建一些可以相互合做的小程序。
          以我的经验来看，所有都集中到一起的方法不如分散式的方法更灵活。
          分散式是指一堆应用的集合，这些应用像一个团队来一起工作以实现最终目标。
          事实上，这也是Unix操作系统背后的基本原理。
          当然，如果把不同的组件合并到一起工作也是很关键的。
          您可认通过脚本来达到这一目的。也可以实际直接从底层构建一组专用单片应用程序。
        </p>

        <p>
          所认问题就变成下面这样：把程序分为几部分。
          再把每部分分为更小的部分， 一直分到一些可以很方便测试的子问题的，并且，从这些更小的部分，可以合起来解决原来的问题以及它的变体。
          把每一个这样的部分写成一个库，为每个库写测试用例，以保证这些库都是可工作的。
          为您的库写一个完整的测试用例是非常重要的。完整的测试用例是指一些程序的集合。
          这些程序如果正确执行(exit(0))，就安静地正常返回，如果执行错误(assert(false),exit(1);)就异常返回。

          测试用例的目的是为了检测库的bug，以及，使您，程序的开发都确信这个库是正常工作的。
          写测试用例的最好时机是尽早。

          别偷懒，别再只是写代码写代码。
          一旦可以把一些新代码放到一起用一些测试程序来测试的时候，尽量地写这些测试程序。
          我不能再强调更多啦。

          写新代码的时候，您总是比幻想您在有效工作。
          但是您只有在明天才知道，您可能需要一整个星期来调试它。

          通常情况下，只有当你给新的功能写完了一个可以工作的测试代码时，你才是真正地产生了新的工作结果，在此之前的任何时候都不算。

          还有另外一种情况您必须写测试用例。当您在正常使用库的时候发现了bug的时候。

          这时，在修改这个bug之前，您应该写一个可以发现这个bug的测试程序。然后才是修改bug。
          通过这种方式，当你在给库添加新功能时，你才能保证不才触发旧的bugs。
        </p>

        <p>
          请随时保持文档最新的状态。写文档最好的时机正是您写完一个可以工作的测试程序的时候。

          您可能会觉得您太忙了以至于不能。但是，真理是：您总是很忙碌。

          在长时间调试这些段错误后，就当作是对这次胜利的庆祝吧，打开编辑器记录下这些酷炫的新功能吧。
        </p>

        <p>
          请确保计算代码和您的I/O代码分开。这样其它开发者就可以重用您的计算代码而不必强制遵循您的I/O模型。

          然后，写程序通过调用您的库集来解决各种问题。

          通过把问题一步一步分割成一个一个有测试套件的库，你就可以写出优秀而强大的代码。

          如果您正在开发一个数字软件，不要希望代码的其它使用者在编写输入文件的时候会获得高分。

          您应该写一个交互式的实用程序，用户可以通过这个程序更加友好地配置输入文件。
          当然，这在Fortran中意味着很大的工作量。但是，你知道更多强大的语言，不是吗？
        </p>

        <p>

          一些有用库的示例包括：线性代数库，一般ODE求解器，插值算法等。

          结果你是您有了两个package，一个packge是有有完整测试用例的库，一个是package是调用库的程序。

          库是被完全测试过的，它可以传递给以后的开发者使用。

          库的代码是那种如果你遵从它，就不需要重写的代码。

          调用库的程序是每个开发者可能都需要重写的。因为不同的人可能需要解决不同的问题。

          拥有一个库包的结果就是C++被提升到一个很高的级别，它更接近于你正在解决的问题。

          一个好的规则是尽量让库足够地复杂（sophisticated），这样每个可执行文件都可以在一个源文件中表示。

          所有这些都听起来像常识，但是您会惊奇地发现，很多的科研开发者都是在维护一个“做所有事情的程序”。
          他们永远都在hack这个程序，直到程序最终变得不可维护。

          你还会更惊讶地发现，一些教授总是搞不明白，为什么对一个其它人写的代码做一个“简单地数学修改”会需要花这么长的时间。
        </p>

        <p>
          每个库都应该有它自己的目录和Makefile。所以一个库包可能有多个子目录，每个子目录是一个库。

          如果您有很多这样的库包时，您也许就想对它们再进一步分组。最后这就成了您的应用程序。

          如果您把这些事情都做正确了。那么您的库包里面应该就包含了足够多的功能，它们可以使您的每个应用程序都有一个源文件。

          这意味着所有源文件都可能在同一个目录内。
        </p>

        <p>
          有时您可能遇到一些现在的库不能做的事情。所以您在您的应用程序源文件中对它做了实现。

          如果您发现您在对这个实现进行拷贝或粘贴时，这就意味着您您需要把它放到库中了。
          而如果它不属于之前写过的任何库，也许就应该新加库了。

          当您处于deadline的时候，可能不太愿意这样做，因为复制粘贴可能更简单。
          问题是，如果您不这样做，您的代码最后会退化到难以使用的情况。
          保持熵（这是什么意思？）减少是每天都需要做的基本工作。
        </p>

        <p>
          最后，谈谈语言选择这个老生常谈的问题。GNU编码标准鼓励大家使用C并尽量避免使用C以外的语言，比如C++或者Fortran。
          C比C++和Fortran的主要优势在于，它产生出的目标文件可以被任何C或者C++编译器成功链接。

          相反地，C++目标文件只能被产成它们的编译器链接。

          对于Fortran来说，先不谈事实上Fortran 90和Fortran 95根本就没有免费的编译器，将Fortran 77和C/C++代码混合到一起是一件很烦的事情。
          所以没有强制性的原因，完全没有必要这样做。

          总而言之，我的建议是使用C++来写代码。C++主要的好处是健壮性。
          如果您知道如何正确地使有和构造函数、析构函数以及引用的话，它们可以帮您避免很多的内存错误。
        </p>

      </div>

    </div>

  </body>

</html>
